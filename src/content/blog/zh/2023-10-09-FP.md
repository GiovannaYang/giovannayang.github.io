---
title: FP增长算法
tags:
  - 数据挖掘
---

该算法不同于Apriori算法的“产生-测试”范型。而是使用一种称作FP树的紧凑数据结构组织数据，并直接从该结构中提取频繁项集。

## 一、基本思想

首先：将代表频繁项集的数据库压缩到FP树上

其次：将FP树划分为一组条件数据库(每个数据数据库关联一个频繁项或“模式段”)，挖掘每个条件数据库获取频繁项集

## 二、如何构造FP树

| TID | Items     |
| --- | --------- |
| 1   | {a,b}     |
| 2   | {b,c,d}   |
| 3   | {a,c,d,e} |
| 4   | {a,d,e}   |
| 5   | {a,b,c}   |
| 6   | {a,b,c,d} |
| 7   | {a}       |
| 8   | {a,b,c}   |
| 9   | {a,b,d}   |
| 10  | {b,c,e}   |

最小支持度计数 = 2

1. 支持度排序：扫描一次数据集，确定每个项的支持度计数。

丢弃非频繁项，而将频繁项按照支持度的递减排序。L = {a:8, b:7, c:6, d:5, e:3} 

2. 构建FP树：第二次扫描数据集，读入第一个事务{a,b}之后，创建标记为a和b的结点。然后形成null->a->b路径。该路径上的所有结点的频度计数为1。

![](/img/posts/zh/2023-10-09/030401.png)

读入第二个事务{b,c,d}之后，为项b，c和d创建新的结点集。

然后，连接结点null->b->c->d，形成一条代表该事务的路径。该路径上的每个结点的频度计数也等于1。

注意：尽管前两个事务具有一个共同项b，但是它们的路径不相交，因为这两个事务没有共同的前缀。

![](/img/posts/zh/2023-10-09/030402.png)

第三个事务{a,c,d,e}与第一个事务共享一个共同的前缀项a，所以第三个事务的路径null->a->c->d->e与第一个事务的路径null-> a->b部分重叠。因为它们的路径重叠，所以结点a的频度计数增加为2。

![](/img/posts/zh/2023-10-09/030403.png)

继续该过程，直到每个事务都映射到FP树的一条路径。

![](/img/posts/zh/2023-10-09/030404.png)

#### 另一个例子

| TID | Items       |
| --- | ----------- |
| 1   | I1,I2,I5    |
| 2   | I2,I4       |
| 3   | I2,I3       |
| 4   | I1,I2,I4    |
| 5   | I1,I3       |
| 6   | I2,I3       |
| 7   | I1,I3       |
| 8   | I1,I2,I3,I5 |
| 9   | I1,I2,I3    |

1. 支持度计数

I1:6, I2:7, I3:6, I4:2, I5:2

排序后：I2,I1,I3,I4,I5

| TID | Items       |
| --- | ----------- |
| 1   | I2,I1,I5    |
| 2   | I2,I4       |
| 3   | I2,I3       |
| 4   | I2,I1,I4    |
| 5   | I1,I3       |
| 6   | I2,I3       |
| 7   | I1,I3       |
| 8   | I2,I1,I3,I5 |
| 9   | I2,I1,I3    |

2. 读入事务建树

![](/img/posts/zh/2023-10-09/030405.png)

## 三、FP树特点

- 通常，FP树的大小比未压缩的数据小，因为购物篮数据的事务常常共享一些共同项。如果共同项较少，FP树对存储空间的压缩效果将不明显。

- FP树的大小也依赖于项如何排序。一般按照支持度计数递减序可以导致较小的FP树。

- FP树还包含一个连接具有相同项的结点的指针列表。这些指针有助于方便快捷地访问树中的项。

## 四、如何在FP树进行频繁模式挖掘

### (1) 构建条件模式基(子数据库)

条件模式基：一个“子数据库”，由FP树中与该后缀模式一起出现的前缀路径集组成。

![](/img/posts/zh/2023-10-09/030406.png)

### (2) 构建条件FP树

将条件模式基看作为事务数据库，构造条件FP树

![](/img/posts/zh/2023-10-09/030407.png)

### (3) 挖掘频繁项集

对每一(条件)树，两种情况

1. 如果(条件)FP树为单个路径，则产生该路径下所有模式的组合。

![](/img/posts/zh/2023-10-09/030408.png)

e.g. I5: {I2,I5:2}, {I1,I5:2}, {I2,I1,I5:2}

1. 如果(条件)FP树为多路径，则针对树的头表中的每一个项，产生对应模式获取频繁模式。

![](/img/posts/zh/2023-10-09/030409.png)

- {I2,I3:4}
    以{I2,I3}构造条件模式基（空）
- {I1,I3:4}
    以{I1,I3}构造条件模式基{I2:2}
    构造条件FP树：<I2:2>

## 五、算法过程描述

![](/img/posts/zh/2023-10-09/030410.png)

![](/img/posts/zh/2023-10-09/030411.png)

## 六、优缺点

优点：

- FP增长算法对长和短的模式都是有效且可伸缩的
- 效率比Apriori算法快了一个数量级

缺点：

- 对内存要求较大，算法实现相对复杂